model small
stack 100h
.186 ; Разрешение команд процессора 80186

.data
simple db 20 dup (7)    ; Массив из 20 байт для хранения чисел
result db '    $'       ; Формат вывода числа с выравниванием по правому краю
nl db 0Dh, 0Ah, '$'     ; Перевод строки и возврат каретки

.code
start:
    mov ax, @data       ; Инициализация сегментного регистра DS
    mov ds, ax

; Заполнение массива numbers
    mov cx, 10          ; Число шагов в цикле (10)
    mov bl, 2           ; Начальное значение (2)
    mov si, 0           ; Начальный индекс массива simple

vvod:
    mov simple[si], bl  ; Запись BL в текущий элемент массива
    mov al, 5
    mul bl              ; Умножение AL на BL (результат в AX)
    mov simple[si + 10], al ; Запись результата во вторую половину массива
    inc si              ; Переход к следующему элементу массива
    add bl, 2           ; Увеличение значения BL на 2
    loop vvod           ; Переход к началу цикла, пока CX != 0

; Вывод массива (2 строки по 10 чисел)
    mov cx, 2           ; Внешний цикл выполняется 2 раза
    mov si, 0           ; Начальный индекс массива simple

outer_loop:
    push cx             ; Сохраняем CX (счётчик внешнего цикла) в стек
    mov cx, 10          ; Устанавливаем счётчик для внутреннего цикла (10 чисел)

vyvod:
    mov al, simple[si]  ; Загружаем элемент массива в AL
    mov bl, 10          ; Основание системы счисления (10)
    call byte_asc       ; Вызов процедуры преобразования числа в строку

    ; Вывод числа на экран
    mov ah, 9           ; Функция DOS для вывода строки
    mov dx, offset result ; Адрес строки result
    int 21h             ; Вызов DOS прерывания

    inc si              ; Переход к следующему элементу массива
    loop vyvod          ; Повторяем внутренний цикл 10 раз

    ; Переход на новую строку после вывода 10 чисел
    mov dx, offset nl   ; Адрес строки nl (новая строка)
    mov ah, 9           ; Функция DOS для вывода строки
    int 21h             ; Вызов DOS прерывания

    pop cx              ; Восстанавливаем CX из стека для внешнего цикла
    loop outer_loop     ; Повторяем внешний цикл 2 раза

    mov ax, 4C00h       ; Завершение программы (корректный код выхода)
    int 21h

; Процедура преобразования числа в строку
byte_asc proc
    pusha               ; Сохраняем регистры
    mov si, 3           ; Конец строки результата (позиция 3)

next_digit:
    dec si              ; Переход к следующей позиции справа налево
    mov ah, 0           ; Обнуляем AH для деления AX на BL
    div bl              ; Деление AX на BL (10)
    add ah, '0'         ; Преобразуем цифру в ASCII-код
    mov result[si], ah  ; Сохраняем ASCII-символ в строке result
    cmp al, 0           ; Проверяем, не нулевое ли частное
    jne next_digit      ; Если не ноль, продолжаем делить

    popa                ; Восстанавливаем регистры
    ret
byte_asc endp

end start